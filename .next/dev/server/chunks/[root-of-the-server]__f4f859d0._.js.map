{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/auth/%5B...nextauth%5D.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcrypt';\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: NextAuthOptions = {\n  session: { strategy: 'jwt' },\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: {\n          label: 'Email',\n          type: 'email',\n          placeholder: 'admin@example.com',\n        },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) return null;\n\n        const user = await prisma.adminUser.findUnique({\n          where: { email: credentials.email },\n        });\n        if (!user) return null;\n\n        const ok = await bcrypt.compare(credentials.password, user.password);\n        if (!ok) return null;\n\n        return {\n          id: user.id.toString(),\n          email: user.email,\n          name: user.name || undefined,\n          role: user.role,\n        } as any;\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = (user as any).role ?? 'admin';\n        token.id = (user as any).id ?? token.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      (session as any).user = session.user ?? {};\n      (session as any).user.role = token.role;\n      (session as any).user.id = token.id;\n      return session;\n    },\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n};\n\nexport default NextAuth(authOptions);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACT,IAAA,oLAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBACL,OAAO;oBACP,MAAM;oBACN,aAAa;gBACf;gBACA,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU,OAAO;gBAE1D,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,UAAU,CAAC;oBAC7C,OAAO;wBAAE,OAAO,YAAY,KAAK;oBAAC;gBACpC;gBACA,IAAI,CAAC,MAAM,OAAO;gBAElB,MAAM,KAAK,MAAM,gHAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBACnE,IAAI,CAAC,IAAI,OAAO;gBAEhB,OAAO;oBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;oBACpB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI,IAAI;oBACnB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI,IAAI;gBACnC,MAAM,EAAE,GAAG,AAAC,KAAa,EAAE,IAAI,MAAM,EAAE;YACzC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC7B,QAAgB,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC;YACxC,QAAgB,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YACtC,QAAgB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YACnC,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC;uCAEe,IAAA,4HAAQ,EAAC"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/lib/coaParsers/novaAnalytic.ts"],"sourcesContent":["// lib/coaParsers/novaAnalytic.ts\r\nimport { LabParser, ParsedCoa } from './types';\r\n\r\nconst STATE_ABBREVS = [\r\n  'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',\r\n  'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',\r\n  'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',\r\n  'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',\r\n  'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY',\r\n];\r\n\r\nfunction detectCityStateFromLine(\r\n  line: string\r\n): { city?: string; state?: string } {\r\n  // e.g. \"65 MILLIKEN STREET, UNIT C PORTLAND ME 04103\"\r\n  const regex = new RegExp(\r\n    `\\\\b([A-Za-z][A-Za-z]+)\\\\s+(${STATE_ABBREVS.join('|')})\\\\s+\\\\d{5}\\\\b`\r\n  );\r\n  const m = line.match(regex);\r\n  if (!m) return {};\r\n  const city = m[1];\r\n  const state = m[2];\r\n  return { city, state };\r\n}\r\n\r\nexport const parseNovaAnalytic: LabParser = (text) => {\r\n  if (!/NOVA ANALYTIC LABS/i.test(text)) {\r\n    return null;\r\n  }\r\n\r\n  const result: ParsedCoa = {\r\n    labName: 'Nova Analytic Labs',\r\n    contaminants: [],\r\n  };\r\n\r\n  const canonicalText = text.replace(/\\r\\n/g, '\\n');\r\n\r\n  // Lab address line\r\n  const labLineMatch = canonicalText.match(\r\n    /NOVA ANALYTIC LABS\\s*\\/\\/\\s*([^\\n]+)/i\r\n  );\r\n  if (labLineMatch) {\r\n    const { city, state } = detectCityStateFromLine(labLineMatch[1]);\r\n    if (city) result.labCity = city;\r\n    if (state) result.labStateCode = state;\r\n  }\r\n\r\n  // Batch code, e.g. \"BATCH: FAIL\"\r\n  const batchMatch =\r\n    canonicalText.match(/BATCH:\\s*([A-Za-z0-9_-]+)/i) ||\r\n    canonicalText.match(/BATCH\\s+RESULT\\s*:\\s*([A-Za-z0-9_-]+)/i);\r\n  if (batchMatch) {\r\n    result.batchCode = batchMatch[1].trim();\r\n  }\r\n\r\n  // Basic cannabinoid metrics\r\n  const thcMatch = canonicalText.match(/Œî-THC:?(\\d+(\\.\\d+)?)\\s*%/i);\r\n  if (thcMatch) result.thcPercent = parseFloat(thcMatch[1]);\r\n\r\n  const totalMatch = canonicalText.match(\r\n    /TOTAL\\s+CANNABINOIDS:?(\\d+(\\.\\d+)?)\\s*%/i\r\n  );\r\n  if (totalMatch) result.totalCannabinoidsPercent = parseFloat(totalMatch[1]);\r\n\r\n  const cbdMatch = canonicalText.match(/CBD:?(\\d+(\\.\\d+)?)\\s*%/i);\r\n  if (cbdMatch) result.cbdPercent = parseFloat(cbdMatch[1]);\r\n\r\n  // Overall batch result: PASS/FAIL\r\n  const batchResultMatch = canonicalText.match(\r\n    /BATCH RESULT:\\s*(PASS|FAIL)/i\r\n  );\r\n  if (batchResultMatch) {\r\n    result.overallPass = batchResultMatch[1].toUpperCase() === 'PASS';\r\n  }\r\n\r\n  // Simple contaminant summary: capture FAIL lines\r\n  const failLines = canonicalText\r\n    .split('\\n')\r\n    .filter((line) => /\\bFAIL\\b/i.test(line));\r\n\r\n  for (const line of failLines) {\r\n    const nameMatch = line.match(/([A-Z][A-Za-z]+)\\s*FAIL/i);\r\n    const name = nameMatch ? nameMatch[1] : 'Unknown';\r\n    result.contaminants.push({\r\n      group: 'OTHER',\r\n      name,\r\n      status: 'FAIL',\r\n      valueRaw: line.trim(),\r\n    });\r\n  }\r\n\r\n  return result;\r\n};\r\n"],"names":[],"mappings":"AAAA,iCAAiC;;;;;AAGjC,MAAM,gBAAgB;IACpB;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IACtD;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IACtD;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IACtD;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IACtD;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;IAAM;CACvD;AAED,SAAS,wBACP,IAAY;IAEZ,sDAAsD;IACtD,MAAM,QAAQ,IAAI,OAChB,CAAC,2BAA2B,EAAE,cAAc,IAAI,CAAC,KAAK,cAAc,CAAC;IAEvE,MAAM,IAAI,KAAK,KAAK,CAAC;IACrB,IAAI,CAAC,GAAG,OAAO,CAAC;IAChB,MAAM,OAAO,CAAC,CAAC,EAAE;IACjB,MAAM,QAAQ,CAAC,CAAC,EAAE;IAClB,OAAO;QAAE;QAAM;IAAM;AACvB;AAEO,MAAM,oBAA+B,CAAC;IAC3C,IAAI,CAAC,sBAAsB,IAAI,CAAC,OAAO;QACrC,OAAO;IACT;IAEA,MAAM,SAAoB;QACxB,SAAS;QACT,cAAc,EAAE;IAClB;IAEA,MAAM,gBAAgB,KAAK,OAAO,CAAC,SAAS;IAE5C,mBAAmB;IACnB,MAAM,eAAe,cAAc,KAAK,CACtC;IAEF,IAAI,cAAc;QAChB,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,wBAAwB,YAAY,CAAC,EAAE;QAC/D,IAAI,MAAM,OAAO,OAAO,GAAG;QAC3B,IAAI,OAAO,OAAO,YAAY,GAAG;IACnC;IAEA,iCAAiC;IACjC,MAAM,aACJ,cAAc,KAAK,CAAC,iCACpB,cAAc,KAAK,CAAC;IACtB,IAAI,YAAY;QACd,OAAO,SAAS,GAAG,UAAU,CAAC,EAAE,CAAC,IAAI;IACvC;IAEA,4BAA4B;IAC5B,MAAM,WAAW,cAAc,KAAK,CAAC;IACrC,IAAI,UAAU,OAAO,UAAU,GAAG,WAAW,QAAQ,CAAC,EAAE;IAExD,MAAM,aAAa,cAAc,KAAK,CACpC;IAEF,IAAI,YAAY,OAAO,wBAAwB,GAAG,WAAW,UAAU,CAAC,EAAE;IAE1E,MAAM,WAAW,cAAc,KAAK,CAAC;IACrC,IAAI,UAAU,OAAO,UAAU,GAAG,WAAW,QAAQ,CAAC,EAAE;IAExD,kCAAkC;IAClC,MAAM,mBAAmB,cAAc,KAAK,CAC1C;IAEF,IAAI,kBAAkB;QACpB,OAAO,WAAW,GAAG,gBAAgB,CAAC,EAAE,CAAC,WAAW,OAAO;IAC7D;IAEA,iDAAiD;IACjD,MAAM,YAAY,cACf,KAAK,CAAC,MACN,MAAM,CAAC,CAAC,OAAS,YAAY,IAAI,CAAC;IAErC,KAAK,MAAM,QAAQ,UAAW;QAC5B,MAAM,YAAY,KAAK,KAAK,CAAC;QAC7B,MAAM,OAAO,YAAY,SAAS,CAAC,EAAE,GAAG;QACxC,OAAO,YAAY,CAAC,IAAI,CAAC;YACvB,OAAO;YACP;YACA,QAAQ;YACR,UAAU,KAAK,IAAI;QACrB;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/lib/coaParsers/registry.ts"],"sourcesContent":["// lib/coaParsers/registry.ts\r\nimport { LabParser, ParsedCoa } from './types';\r\nimport { parseNovaAnalytic } from './novaAnalytic';\r\n\r\ntype LabRegistryEntry = {\r\n  slug: string;\r\n  displayName: string;\r\n  states: string[];  // where they mainly operate\r\n  patterns: RegExp[]; // name/branding text in COA\r\n  parser: LabParser;\r\n  website?: string;\r\n};\r\n\r\nconst noopParser: LabParser = (text) => ({\r\n  contaminants: [],\r\n});\r\n\r\nexport const LAB_REGISTRY: LabRegistryEntry[] = [\r\n  {\r\n    slug: 'nova-analytic-labs',\r\n    displayName: 'Nova Analytic Labs',\r\n    states: ['ME'],\r\n    patterns: [/NOVA ANALYTIC LABS?/i],\r\n    parser: parseNovaAnalytic,\r\n    website: 'https://www.nova-analyticlabs.com/',\r\n  },\r\n  {\r\n    slug: 'mcr-labs',\r\n    displayName: 'MCR Labs',\r\n    states: ['MA', 'CT', 'PA'],\r\n    patterns: [/MCR LABS?/i],\r\n    parser: noopParser,\r\n    website: 'https://mcrlabs.com/',\r\n  },\r\n  {\r\n    slug: 'proverde-labs',\r\n    displayName: 'ProVerde Laboratories',\r\n    states: ['MA', 'ME'],\r\n    patterns: [/PROVERDE LAB/i],\r\n    parser: noopParser,\r\n    website: 'https://www.proverdelabs.com/',\r\n  },\r\n  {\r\n    slug: 'sc-labs',\r\n    displayName: 'SC Labs',\r\n    states: ['CA', 'CO', 'MI', 'OR', 'TX'],\r\n    patterns: [/SC LABS?/i],\r\n    parser: noopParser,\r\n    website: 'https://www.sclabs.com/',\r\n  },\r\n  {\r\n    slug: 'kaycha-labs',\r\n    displayName: 'Kaycha Labs',\r\n    states: ['FL', 'CA', 'MA', 'NY', 'CO', 'TN'],\r\n    patterns: [/KAYCHA LABS?/i],\r\n    parser: noopParser,\r\n    website: 'https://kaychalabs.com/',\r\n  },\r\n  {\r\n    slug: 'green-leaf-lab',\r\n    displayName: 'Green Leaf Lab',\r\n    states: ['OR', 'CA'],\r\n    patterns: [/GREEN LEAF LAB/i],\r\n    parser: noopParser,\r\n    website: 'https://www.greenleaflab.org/',\r\n  },\r\n  {\r\n    slug: 'confidence-analytics',\r\n    displayName: 'Confidence Analytics',\r\n    states: ['WA'],\r\n    patterns: [/CONFIDENCE ANALYTICS/i],\r\n    parser: noopParser,\r\n    website: 'https://www.confidenceanalytics.com/',\r\n  },\r\n  // Add new labs here as you get COA examples.\r\n];\r\n\r\nexport function findLabEntry(text: string): LabRegistryEntry | null {\r\n  for (const entry of LAB_REGISTRY) {\r\n    if (entry.patterns.some((re) => re.test(text))) {\r\n      return entry;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function parseCoa(text: string): ParsedCoa {\r\n  const entry = findLabEntry(text);\r\n\r\n  if (entry) {\r\n    const parsed = entry.parser(text);\r\n    if (parsed) {\r\n      return {\r\n        ...parsed,\r\n        labName: parsed.labName ?? entry.displayName,\r\n        labStateCode: parsed.labStateCode ?? entry.states[0],\r\n        contaminants: parsed.contaminants ?? [],\r\n      };\r\n    }\r\n  }\r\n\r\n  // Generic fallback parser (THC/CBD/Total Cannabinoids only)\r\n  const generic: ParsedCoa = {\r\n    contaminants: [],\r\n  };\r\n\r\n  const canonical = text.replace(/\\r\\n/g, '\\n');\r\n\r\n  const thcMatch =\r\n    canonical.match(/TOTAL\\s+THC[:\\s]+(\\d+(\\.\\d+)?)\\s*%/i) ||\r\n    canonical.match(/Œî-?9?[-\\s]*THC[:\\s]+(\\d+(\\.\\d+)?)\\s*%/i);\r\n  if (thcMatch) generic.thcPercent = parseFloat(thcMatch[1]);\r\n\r\n  const cbdMatch =\r\n    canonical.match(/TOTAL\\s+CBD[:\\s]+(\\d+(\\.\\d+)?)\\s*%/i) ||\r\n    canonical.match(/\\bCBD[:\\s]+(\\d+(\\.\\d+)?)\\s*%/i);\r\n  if (cbdMatch) generic.cbdPercent = parseFloat(cbdMatch[1]);\r\n\r\n  const totalCannMatch = canonical.match(\r\n    /TOTAL\\s+CANNABINOIDS?[:\\s]+(\\d+(\\.\\d+)?)\\s*%/i\r\n  );\r\n  if (totalCannMatch) {\r\n    generic.totalCannabinoidsPercent = parseFloat(totalCannMatch[1]);\r\n  }\r\n\r\n  return generic;\r\n}\r\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;;;AAE7B;;AAWA,MAAM,aAAwB,CAAC,OAAS,CAAC;QACvC,cAAc,EAAE;IAClB,CAAC;AAEM,MAAM,eAAmC;IAC9C;QACE,MAAM;QACN,aAAa;QACb,QAAQ;YAAC;SAAK;QACd,UAAU;YAAC;SAAuB;QAClC,QAAQ,+IAAiB;QACzB,SAAS;IACX;IACA;QACE,MAAM;QACN,aAAa;QACb,QAAQ;YAAC;YAAM;YAAM;SAAK;QAC1B,UAAU;YAAC;SAAa;QACxB,QAAQ;QACR,SAAS;IACX;IACA;QACE,MAAM;QACN,aAAa;QACb,QAAQ;YAAC;YAAM;SAAK;QACpB,UAAU;YAAC;SAAgB;QAC3B,QAAQ;QACR,SAAS;IACX;IACA;QACE,MAAM;QACN,aAAa;QACb,QAAQ;YAAC;YAAM;YAAM;YAAM;YAAM;SAAK;QACtC,UAAU;YAAC;SAAY;QACvB,QAAQ;QACR,SAAS;IACX;IACA;QACE,MAAM;QACN,aAAa;QACb,QAAQ;YAAC;YAAM;YAAM;YAAM;YAAM;YAAM;SAAK;QAC5C,UAAU;YAAC;SAAgB;QAC3B,QAAQ;QACR,SAAS;IACX;IACA;QACE,MAAM;QACN,aAAa;QACb,QAAQ;YAAC;YAAM;SAAK;QACpB,UAAU;YAAC;SAAkB;QAC7B,QAAQ;QACR,SAAS;IACX;IACA;QACE,MAAM;QACN,aAAa;QACb,QAAQ;YAAC;SAAK;QACd,UAAU;YAAC;SAAwB;QACnC,QAAQ;QACR,SAAS;IACX;CAED;AAEM,SAAS,aAAa,IAAY;IACvC,KAAK,MAAM,SAAS,aAAc;QAChC,IAAI,MAAM,QAAQ,CAAC,IAAI,CAAC,CAAC,KAAO,GAAG,IAAI,CAAC,QAAQ;YAC9C,OAAO;QACT;IACF;IACA,OAAO;AACT;AAEO,SAAS,SAAS,IAAY;IACnC,MAAM,QAAQ,aAAa;IAE3B,IAAI,OAAO;QACT,MAAM,SAAS,MAAM,MAAM,CAAC;QAC5B,IAAI,QAAQ;YACV,OAAO;gBACL,GAAG,MAAM;gBACT,SAAS,OAAO,OAAO,IAAI,MAAM,WAAW;gBAC5C,cAAc,OAAO,YAAY,IAAI,MAAM,MAAM,CAAC,EAAE;gBACpD,cAAc,OAAO,YAAY,IAAI,EAAE;YACzC;QACF;IACF;IAEA,4DAA4D;IAC5D,MAAM,UAAqB;QACzB,cAAc,EAAE;IAClB;IAEA,MAAM,YAAY,KAAK,OAAO,CAAC,SAAS;IAExC,MAAM,WACJ,UAAU,KAAK,CAAC,0CAChB,UAAU,KAAK,CAAC;IAClB,IAAI,UAAU,QAAQ,UAAU,GAAG,WAAW,QAAQ,CAAC,EAAE;IAEzD,MAAM,WACJ,UAAU,KAAK,CAAC,0CAChB,UAAU,KAAK,CAAC;IAClB,IAAI,UAAU,QAAQ,UAAU,GAAG,WAAW,QAAQ,CAAC,EAAE;IAEzD,MAAM,iBAAiB,UAAU,KAAK,CACpC;IAEF,IAAI,gBAAgB;QAClB,QAAQ,wBAAwB,GAAG,WAAW,cAAc,CAAC,EAAE;IACjE;IAEA,OAAO;AACT"}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/admin/uploads/index.ts"],"sourcesContent":["// pages/api/admin/uploads/index.ts\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '../../auth/[...nextauth]';\nimport { PrismaClient } from '@prisma/client';\nimport multer from 'multer';\nimport pdfParse from 'pdf-parse';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport crypto from 'crypto';\n\nimport { parseCoa } from '../../../../lib/coaParsers/registry';\n\nconst prisma = new PrismaClient();\n\n// --- Multer: in-memory upload, we write to disk ourselves ---\nconst upload = multer({ storage: multer.memoryStorage() });\n\n// Helper to run middleware (multer) inside Next API route\nfunction runMiddleware(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  fn: (...args: any[]) => void\n) {\n  return new Promise<void>((resolve, reject) => {\n    fn(req, res, (result: unknown) => {\n      if (result instanceof Error) return reject(result);\n      return resolve();\n    });\n  });\n}\n\n// Small helpers\nfunction slugify(input: string): string {\n  return input\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n}\n\n// Very simple fallback batch-code detection if parser doesn‚Äôt give one\nfunction detectBatchCode(text: string): string | null {\n  const m =\n    text.match(/batch\\s*[:#]\\s*([A-Za-z0-9\\-_.]+)/i) ||\n    text.match(/lot\\s*[:#]\\s*([A-Za-z0-9\\-_.]+)/i);\n  return m ? m[1].trim() : null;\n}\n\n// Very simple fallback lab name detection\nfunction detectLabName(text: string): string | null {\n  const lines = text\n    .split(/\\r?\\n/)\n    .map((l) => l.trim())\n    .filter(Boolean);\n\n  // look for something with \"LAB\" in it\n  const candidate = lines.find((l) => /lab(s)?/i.test(l));\n  return candidate || null;\n}\n\nexport const config = {\n  api: {\n    bodyParser: false, // let multer handle the body\n  },\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // üîê Require any authenticated session (we can tighten to role:\"admin\" later)\n  const session = await getServerSession(req, res, authOptions);\n\n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  // -------- GET: list uploaded documents --------\n  if (req.method === 'GET') {\n    try {\n      const docs = await prisma.uploadedDocument.findMany({\n        orderBy: { createdAt: 'desc' },\n        include: {\n          labResult: {\n            select: { id: true },\n          },\n        },\n      });\n\n      return res.status(200).json(docs);\n    } catch (e: any) {\n      console.error('Failed to list uploads', e);\n      return res\n        .status(500)\n        .json({ error: e?.message || 'Failed to list uploads' });\n    }\n  }\n\n  // -------- POST: upload + parse a COA PDF --------\n  if (req.method === 'POST') {\n    try {\n      // run multer to populate req.file\n      await runMiddleware(req, res, upload.single('file'));\n\n      const anyReq = req as any;\n      const file = anyReq.file as Express.Multer.File | undefined;\n\n      if (!file) {\n        return res.status(400).json({ error: 'No file uploaded' });\n      }\n\n      if (file.mimetype !== 'application/pdf') {\n        return res.status(400).json({ error: 'Only PDF files are allowed' });\n      }\n\n      // SHA-256 hash to de-dupe\n      const sha256 = crypto\n        .createHash('sha256')\n        .update(file.buffer)\n        .digest('hex');\n\n      // Check if this COA is already in the DB\n      const existing = await prisma.uploadedDocument.findUnique({\n        where: { sha256 },\n        include: { labResult: { select: { id: true } } },\n      });\n\n      if (existing) {\n        return res.status(200).json({\n          reused: true,\n          document: existing,\n          labResult: existing.labResult || null,\n        });\n      }\n\n      // Ensure upload directory exists\n      const uploadDir = path.join(process.cwd(), 'uploads', 'coa');\n      await fs.mkdir(uploadDir, { recursive: true });\n\n      const safeName = `${sha256}.pdf`;\n      const finalPath = path.join(uploadDir, safeName);\n\n      // Write PDF to disk\n      await fs.writeFile(finalPath, file.buffer);\n\n      // Extract text from PDF\n      let extractedText = '';\n      try {\n        const parsed = await pdfParse(file.buffer);\n        extractedText = parsed.text || '';\n      } catch (err) {\n        console.error('PDF parse error', err);\n      }\n\n      // Try lab-specific parser first\n      let parsedCoa: any = null;\n      if (extractedText) {\n        try {\n          parsedCoa = parseCoa(extractedText);\n        } catch (err) {\n          console.error('parseCoa() error', err);\n        }\n      }\n\n      const batchCode =\n        parsedCoa?.batchCode || detectBatchCode(extractedText) || null;\n      const labName = parsedCoa?.labName || detectLabName(extractedText) || null;\n\n      // Create UploadedDocument record\n      const document = await prisma.uploadedDocument.create({\n        data: {\n          filePath: finalPath,\n          fileName: file.originalname,\n          mimeType: file.mimetype,\n          size: file.size,\n          sha256,\n          extractedText,\n          batchCode,\n          labName,\n          uploader: (session.user as any)?.email || null,\n          verified: false,\n        },\n      });\n\n      // Optionally create Lab / Batch / LabResult\n      let labResult = null;\n\n      if (parsedCoa) {\n        const thcPercent =\n          parsedCoa.thcPercent ??\n          parsedCoa.thc ??\n          parsedCoa.totalTHC ??\n          null;\n        const cbdPercent =\n          parsedCoa.cbdPercent ??\n          parsedCoa.cbd ??\n          parsedCoa.totalCBD ??\n          null;\n        const totalCannabinoidsPercent =\n          parsedCoa.totalCannabinoidsPercent ??\n          parsedCoa.totalCannabinoids ??\n          null;\n        const totalTerpenesPercent =\n          parsedCoa.totalTerpenesPercent ??\n          parsedCoa.totalTerpenes ??\n          null;\n\n        // Upsert Lab if we have a name (slug is unique in schema)\n        let labRecord = null;\n        if (labName) {\n          const slug = slugify(labName);\n          labRecord = await prisma.lab.upsert({\n            where: { slug },\n            update: { name: labName },\n            create: {\n              name: labName,\n              slug,\n              stateCode: parsedCoa.stateCode || parsedCoa.jurisdiction || null,\n            },\n          });\n        }\n\n        // üîÅ Manual \"upsert\" for Batch by batchCode (since batchCode is NOT unique)\n        let batchRecord = null;\n        if (batchCode) {\n          const existingBatch = await prisma.batch.findFirst({\n            where: { batchCode },\n          });\n\n          if (existingBatch) {\n            batchRecord = await prisma.batch.update({\n              where: { id: existingBatch.id },\n              data: {\n                productName:\n                  parsedCoa.productName ?? existingBatch.productName,\n                jurisdiction:\n                  parsedCoa.jurisdiction ?? existingBatch.jurisdiction,\n                stateCode:\n                  parsedCoa.stateCode ??\n                  parsedCoa.jurisdiction ??\n                  existingBatch.stateCode,\n              },\n            });\n          } else {\n            batchRecord = await prisma.batch.create({\n              data: {\n                batchCode,\n                productName: parsedCoa.productName || null,\n                jurisdiction: parsedCoa.jurisdiction || null,\n                stateCode:\n                  parsedCoa.stateCode || parsedCoa.jurisdiction || null,\n                isActive: true,\n              },\n            });\n          }\n        }\n\n        // Create LabResult and connect to UploadedDocument + Batch/Lab\n        labResult = await prisma.labResult.create({\n          data: {\n            uploadedDocument: { connect: { id: document.id } },\n\n            // If we already have a batchRecord, connect; otherwise create a simple fallback batch\n            batch: batchRecord\n              ? { connect: { id: batchRecord.id } }\n              : {\n                  create: {\n                    batchCode: batchCode || `COA-${document.id}`,\n                    productName: parsedCoa.productName || null,\n                    jurisdiction: parsedCoa.jurisdiction || null,\n                    stateCode:\n                      parsedCoa.stateCode || parsedCoa.jurisdiction || null,\n                    isActive: true,\n                  },\n                },\n\n            lab: labRecord\n              ? { connect: { id: labRecord.id } }\n              : undefined,\n\n            coaIdentifier:\n              parsedCoa.coaIdentifier || parsedCoa.sampleId || null,\n            sampleId: parsedCoa.sampleId || null,\n            sampleType: parsedCoa.sampleType || null,\n\n            testedAt: parsedCoa.testedAt\n              ? new Date(parsedCoa.testedAt)\n              : null,\n            reportedAt: parsedCoa.reportedAt\n              ? new Date(parsedCoa.reportedAt)\n              : null,\n\n            thcPercent,\n            cbdPercent,\n            totalCannabinoidsPercent,\n            totalTerpenesPercent,\n\n            passed:\n              typeof parsedCoa.passed === 'boolean'\n                ? parsedCoa.passed\n                : null,\n            pesticidesPass:\n              typeof parsedCoa.pesticidesPass === 'boolean'\n                ? parsedCoa.pesticidesPass\n                : null,\n            solventsPass:\n              typeof parsedCoa.solventsPass === 'boolean'\n                ? parsedCoa.solventsPass\n                : null,\n            heavyMetalsPass:\n              typeof parsedCoa.heavyMetalsPass === 'boolean'\n                ? parsedCoa.heavyMetalsPass\n                : null,\n            microbialsPass:\n              typeof parsedCoa.microbialsPass === 'boolean'\n                ? parsedCoa.microbialsPass\n                : null,\n\n            moisturePercent:\n              typeof parsedCoa.moisturePercent === 'number'\n                ? parsedCoa.moisturePercent\n                : null,\n            waterActivity:\n              typeof parsedCoa.waterActivity === 'number'\n                ? parsedCoa.waterActivity\n                : null,\n\n            analyteSummary: parsedCoa.analyteSummary || null,\n            rawJson: parsedCoa.rawJson || parsedCoa || null,\n          },\n        });\n      }\n\n      return res.status(200).json({\n        reused: false,\n        document,\n        labResult,\n      });\n    } catch (e: any) {\n      console.error('Error handling upload', e);\n      return res\n        .status(500)\n        .json({ error: e?.message || 'Failed to handle upload' });\n    }\n  }\n\n  // Any other method\n  res.setHeader('Allow', ['GET', 'POST']);\n  return res.status(405).end();\n}\n"],"names":[],"mappings":"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"}}]
}