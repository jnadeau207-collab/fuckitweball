{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/auth/%5B...nextauth%5D.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcrypt';\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: NextAuthOptions = {\n  session: { strategy: 'jwt' },\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: {\n          label: 'Email',\n          type: 'email',\n          placeholder: 'admin@example.com',\n        },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) return null;\n\n        const user = await prisma.adminUser.findUnique({\n          where: { email: credentials.email },\n        });\n        if (!user) return null;\n\n        const ok = await bcrypt.compare(credentials.password, user.password);\n        if (!ok) return null;\n\n        return {\n          id: user.id.toString(),\n          email: user.email,\n          name: user.name || undefined,\n          role: user.role,\n        } as any;\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = (user as any).role ?? 'admin';\n        token.id = (user as any).id ?? token.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      (session as any).user = session.user ?? {};\n      (session as any).user.role = token.role;\n      (session as any).user.id = token.id;\n      return session;\n    },\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n};\n\nexport default NextAuth(authOptions);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACT,IAAA,oLAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBACL,OAAO;oBACP,MAAM;oBACN,aAAa;gBACf;gBACA,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU,OAAO;gBAE1D,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,UAAU,CAAC;oBAC7C,OAAO;wBAAE,OAAO,YAAY,KAAK;oBAAC;gBACpC;gBACA,IAAI,CAAC,MAAM,OAAO;gBAElB,MAAM,KAAK,MAAM,gHAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBACnE,IAAI,CAAC,IAAI,OAAO;gBAEhB,OAAO;oBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;oBACpB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI,IAAI;oBACnB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI,IAAI;gBACnC,MAAM,EAAE,GAAG,AAAC,KAAa,EAAE,IAAI,MAAM,EAAE;YACzC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC7B,QAAgB,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC;YACxC,QAAgB,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YACtC,QAAgB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YACnC,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC;uCAEe,IAAA,4HAAQ,EAAC"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/admin/uploads/index.ts"],"sourcesContent":["// pages/api/admin/uploads/index.ts\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '../../auth/[...nextauth]';\nimport { PrismaClient } from '@prisma/client';\nimport multer from 'multer';\nimport pdfParse from 'pdf-parse';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport crypto from 'crypto';\n\nconst prisma = new PrismaClient();\n\n// Use memory storage; we handle writing to disk ourselves\nconst upload = multer({ storage: multer.memoryStorage() });\n\n// Needed so Next.js doesn’t try to body-parse the multipart request\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\nfunction runMiddleware(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  fn: (...args: any[]) => void\n) {\n  return new Promise<void>((resolve, reject) => {\n    fn(req, res, (result: unknown) => {\n      if (result instanceof Error) {\n        return reject(result);\n      }\n      return resolve();\n    });\n  });\n}\n\ntype ParsedMeta = {\n  labName: string | null;\n  batchCode: string | null;\n  sampleId: string | null;\n  sampleType: string | null;\n  thcPercent: number | null;\n  cbdPercent: number | null;\n  totalCannabinoidsPercent: number | null;\n  passed: boolean | null;\n  stateCode: string | null;\n  jurisdiction: string | null;\n};\n\nfunction normalizeText(text: string | null | undefined): string {\n  if (!text) return '';\n  return text.replace(/\\r\\n/g, '\\n').replace(/\\u0000/g, '').trim();\n}\n\nfunction isBadBatchCode(code: string | null | undefined): boolean {\n  if (!code) return true;\n  const trimmed = code.trim();\n  if (!trimmed) return true;\n  // Avoid \"PASS\", \"PASSED\", \"FAIL\", \"FAILED\" as batch codes\n  return /^(PASS(ED)?|FAIL(ED)?)$/i.test(trimmed);\n}\n\nfunction slugifyLabName(name: string): string {\n  const base = name\n    .toLowerCase()\n    .replace(/labs?$/i, '') // strip trailing \"Lab\" / \"Labs\"\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '');\n  return base || 'lab-' + crypto.randomBytes(4).toString('hex');\n}\n\n/**\n * Heuristic parser specifically for Nova Analytic Labs (TagLeaf COAs)\n */\nfunction parseNovaAnalyticLabs(text: string): ParsedMeta | null {\n  const normalized = normalizeText(text);\n  if (!/nova analytic labs/i.test(normalized)) {\n    return null;\n  }\n\n  let labName = 'Nova Analytic Labs';\n\n  let batchCode: string | null = null;\n  let sampleId: string | null = null;\n  let sampleType: string | null = null;\n  let thcPercent: number | null = null;\n  let cbdPercent: number | null = null;\n  let totalCannabinoidsPercent: number | null = null;\n  let passed: boolean | null = null;\n\n  // SAMPLE ID\n  const sampleMatch =\n    normalized.match(/SAMPLE\\s+ID\\s*:\\s*([A-Z0-9-]+)/i) ||\n    normalized.match(/SAMPLE\\s+ID:\\s*([A-Z0-9-]+)/i);\n  if (sampleMatch) {\n    sampleId = sampleMatch[1].trim();\n  }\n\n  // MATRIX (sample type)\n  const matrixMatch = normalized.match(/MATRIX\\s*:\\s*([A-Z ]+)/i);\n  if (matrixMatch) {\n    sampleType = matrixMatch[1].trim();\n  }\n\n  // BATCH RESULT PASS / FAIL\n  const resultMatch = normalized.match(\n    /BATCH\\s+RESULT\\s*:\\s*(PASS(?:ED)?|FAIL(?:ED)?)/i\n  );\n  if (resultMatch) {\n    passed = /^PASS/i.test(resultMatch[1]);\n  }\n\n  // BATCH CODE – avoid PASS/FAIL\n  const batchMatch =\n    normalized.match(/BATCH\\s+NO\\.\\s*:\\s*([A-Z0-9-]+)/i) ||\n    normalized.match(/BATCH\\s*:\\s*([A-Z0-9-]+)/i);\n  if (batchMatch) {\n    const candidate = batchMatch[1].trim();\n    if (!isBadBatchCode(candidate)) {\n      batchCode = candidate;\n    }\n  }\n\n  // Older Nova flower COAs: \"Δ-THC:28.5 %\" and \"TOTAL CANNABINOIDS:29.1 %\"\n  const thcMatch = normalized.match(/Δ-THC\\s*:?\\s*([0-9.]+)\\s*%/i);\n  if (thcMatch) {\n    thcPercent = parseFloat(thcMatch[1]);\n  }\n\n  const cbdMatch = normalized.match(/\\bCBD\\s*:?\\s*([0-9.]+)\\s*%/i);\n  if (cbdMatch) {\n    cbdPercent = parseFloat(cbdMatch[1]);\n  }\n\n  const totalMatch = normalized.match(\n    /TOTAL\\s+CANNABINOIDS\\s*:?\\s*([0-9.]+)\\s*%/i\n  );\n  if (totalMatch) {\n    totalCannabinoidsPercent = parseFloat(totalMatch[1]);\n  }\n\n  // Nova is Maine in our dataset\n  const stateCode = 'ME';\n  const jurisdiction = 'ME';\n\n  return {\n    labName,\n    batchCode,\n    sampleId,\n    sampleType,\n    thcPercent,\n    cbdPercent,\n    totalCannabinoidsPercent,\n    passed,\n    stateCode,\n    jurisdiction,\n  };\n}\n\n/**\n * Generic fallback parser for arbitrary labs.\n */\nfunction basicHeuristicParse(text: string): ParsedMeta {\n  const normalized = normalizeText(text);\n\n  let labName: string | null = null;\n  let batchCode: string | null = null;\n  let sampleId: string | null = null;\n  let sampleType: string | null = null;\n  let thcPercent: number | null = null;\n  let cbdPercent: number | null = null;\n  let totalCannabinoidsPercent: number | null = null;\n  let passed: boolean | null = null;\n  let stateCode: string | null = null;\n  let jurisdiction: string | null = null;\n\n  // Generic lab name heuristic\n  const labMatch = normalized.match(/([A-Z][A-Za-z0-9 &]+Labs?)/);\n  if (labMatch) {\n    labName = labMatch[1].trim();\n  }\n\n  // Generic batch code\n  const batchMatch =\n    normalized.match(/BATCH\\s+NO\\.\\s*:\\s*([A-Z0-9-]+)/i) ||\n    normalized.match(/BATCH\\s*:\\s*([A-Z0-9-]+)/i);\n  if (batchMatch) {\n    const candidate = batchMatch[1].trim();\n    if (!isBadBatchCode(candidate)) {\n      batchCode = candidate;\n    }\n  }\n\n  // Sample id\n  const sampleMatch = normalized.match(/SAMPLE\\s+ID\\s*:\\s*([A-Z0-9-]+)/i);\n  if (sampleMatch) {\n    sampleId = sampleMatch[1].trim();\n  }\n\n  // Matrix / sample type\n  const matrixMatch = normalized.match(/MATRIX\\s*:\\s*([A-Z ]+)/i);\n  if (matrixMatch) {\n    sampleType = matrixMatch[1].trim();\n  }\n\n  // Pass/fail\n  const resultMatch = normalized.match(\n    /BATCH\\s+RESULT\\s*:\\s*(PASS(?:ED)?|FAIL(?:ED)?)/i\n  );\n  if (resultMatch) {\n    passed = /^PASS/i.test(resultMatch[1]);\n  }\n\n  // Potency (generic)\n  const thcMatch = normalized.match(/THC\\s*:?\\s*([0-9.]+)\\s*%/i);\n  if (thcMatch) {\n    thcPercent = parseFloat(thcMatch[1]);\n  }\n\n  const cbdMatch = normalized.match(/\\bCBD\\s*:?\\s*([0-9.]+)\\s*%/i);\n  if (cbdMatch) {\n    cbdPercent = parseFloat(cbdMatch[1]);\n  }\n\n  const totalMatch = normalized.match(\n    /TOTAL\\s+CANNABINOIDS\\s*:?\\s*([0-9.]+)\\s*%/i\n  );\n  if (totalMatch) {\n    totalCannabinoidsPercent = parseFloat(totalMatch[1]);\n  }\n\n  // Naive state inference\n  if (/\\bME\\s+\\d{5}\\b/i.test(normalized)) {\n    stateCode = 'ME';\n    jurisdiction = 'ME';\n  }\n\n  return {\n    labName,\n    batchCode,\n    sampleId,\n    sampleType,\n    thcPercent,\n    cbdPercent,\n    totalCannabinoidsPercent,\n    passed,\n    stateCode,\n    jurisdiction,\n  };\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  const session = await getServerSession(req, res, authOptions as any);\n\n  if (!session || !session.user || (session.user as any).role !== 'admin') {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  // -------- GET: list uploaded COAs --------\n  if (req.method === 'GET') {\n    const docs = await prisma.uploadedDocument.findMany({\n      orderBy: { createdAt: 'desc' },\n      include: {\n        labResult: true,\n      },\n    });\n    return res.status(200).json(docs);\n  }\n\n  // -------- POST: upload + parse COA --------\n  if (req.method === 'POST') {\n    try {\n      await runMiddleware(req, res, upload.single('file'));\n\n      const anyReq = req as any;\n      const file = anyReq.file as\n        | {\n            buffer: Buffer;\n            mimetype: string;\n            originalname: string;\n            size: number;\n          }\n        | undefined;\n\n      if (!file) {\n        return res.status(400).json({ error: 'No file uploaded' });\n      }\n\n      if (file.mimetype !== 'application/pdf') {\n        return res\n          .status(400)\n          .json({ error: 'Only application/pdf files are supported' });\n      }\n\n      // Hash and dedupe\n      const sha256 = crypto\n        .createHash('sha256')\n        .update(file.buffer)\n        .digest('hex');\n\n      const existing = await prisma.uploadedDocument.findUnique({\n        where: { sha256 },\n        include: { labResult: true },\n      });\n\n      if (existing) {\n        return res.status(200).json({\n          reused: true,\n          document: existing,\n          labResult: existing.labResult,\n        });\n      }\n\n      // Persist to disk\n      const uploadsDir = path.join(process.cwd(), 'uploads', 'coas');\n      await fs.mkdir(uploadsDir, { recursive: true });\n\n      const filePath = path.join(uploadsDir, `${sha256}.pdf`);\n      await fs.writeFile(filePath, file.buffer);\n\n      // Extract text via pdf-parse\n      let extractedText = '';\n      try {\n        const parsed = await pdfParse(file.buffer);\n        extractedText = normalizeText(parsed.text);\n      } catch (err) {\n        console.error('pdf-parse failed, continuing with empty text', err);\n        extractedText = '';\n      }\n\n      // --- Parse metadata (Nova first, then generic fallback) ---\n      let meta: ParsedMeta = {\n        labName: null,\n        batchCode: null,\n        sampleId: null,\n        sampleType: null,\n        thcPercent: null,\n        cbdPercent: null,\n        totalCannabinoidsPercent: null,\n        passed: null,\n        stateCode: null,\n        jurisdiction: null,\n      };\n\n      const nova = parseNovaAnalyticLabs(extractedText);\n      if (nova) {\n        meta = nova;\n      } else {\n        meta = basicHeuristicParse(extractedText);\n      }\n\n      // --- Create UploadedDocument row ---\n      const document = await prisma.uploadedDocument.create({\n        data: {\n          filePath,\n          fileName: file.originalname,\n          mimeType: file.mimetype,\n          size: file.size,\n          sha256,\n          extractedText: extractedText || null,\n          labName: meta.labName,\n          batchCode: meta.batchCode,\n          uploader:\n            (session.user as any).email ||\n            (session.user as any).name ||\n            'unknown',\n          // verified stays default false\n        },\n      });\n\n      // --- Upsert Lab (if we have a lab name) ---\n      let labRecord: any = null;\n      if (meta.labName) {\n        const slug = slugifyLabName(meta.labName);\n\n        labRecord = await prisma.lab.upsert({\n          where: { slug },\n          update: {\n            name: meta.labName,\n            stateCode: meta.stateCode ?? undefined,\n            city: meta.stateCode === 'ME' ? 'Portland' : undefined,\n          },\n          create: {\n            name: meta.labName,\n            slug,\n            stateCode: meta.stateCode ?? undefined,\n            city: meta.stateCode === 'ME' ? 'Portland' : undefined,\n          },\n        });\n      }\n\n      // --- Create/find Batch (if we have a batch code) ---\n      let batchRecord: any = null;\n      if (meta.batchCode) {\n        batchRecord = await prisma.batch.findFirst({\n          where: { batchCode: meta.batchCode },\n        });\n\n        if (!batchRecord) {\n          batchRecord = await prisma.batch.create({\n            data: {\n              batchCode: meta.batchCode,\n              jurisdiction: meta.jurisdiction,\n              stateCode: meta.stateCode ?? meta.jurisdiction,\n              isActive: true,\n            },\n          });\n        }\n      }\n\n      // --- Create LabResult ONLY if we have a Batch ---\n      let labResult: any = null;\n      if (batchRecord) {\n        const labConnect =\n          labRecord != null ? { lab: { connect: { id: labRecord.id } } } : {};\n\n        labResult = await prisma.labResult.create({\n          data: {\n            batch: { connect: { id: batchRecord.id } }, // <-- REQUIRED RELATION\n            ...labConnect,\n            uploadedDocument: { connect: { id: document.id } },\n            sampleId: meta.sampleId,\n            sampleType: meta.sampleType,\n            thcPercent: meta.thcPercent,\n            cbdPercent: meta.cbdPercent,\n            totalCannabinoidsPercent: meta.totalCannabinoidsPercent,\n            passed: meta.passed,\n          },\n        });\n      }\n\n      return res.status(200).json({\n        reused: false,\n        document: {\n          ...document,\n          labResult,\n        },\n        labResult,\n      });\n    } catch (err: any) {\n      console.error('Error handling upload', err);\n      return res\n        .status(500)\n        .json({ error: err?.message || 'Failed to handle upload' });\n    }\n  }\n\n  // Unsupported method\n  return res.status(405).end();\n}\n"],"names":[],"mappings":"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"}}]
}