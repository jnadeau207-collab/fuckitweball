{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/auth/%5B...nextauth%5D.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcrypt';\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: NextAuthOptions = {\n  session: { strategy: 'jwt' },\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: {\n          label: 'Email',\n          type: 'email',\n          placeholder: 'admin@example.com',\n        },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) return null;\n\n        const user = await prisma.adminUser.findUnique({\n          where: { email: credentials.email },\n        });\n        if (!user) return null;\n\n        const ok = await bcrypt.compare(credentials.password, user.password);\n        if (!ok) return null;\n\n        return {\n          id: user.id.toString(),\n          email: user.email,\n          name: user.name || undefined,\n          role: user.role,\n        } as any;\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = (user as any).role ?? 'admin';\n        token.id = (user as any).id ?? token.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      (session as any).user = session.user ?? {};\n      (session as any).user.role = token.role;\n      (session as any).user.id = token.id;\n      return session;\n    },\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n};\n\nexport default NextAuth(authOptions);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACT,IAAA,oLAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBACL,OAAO;oBACP,MAAM;oBACN,aAAa;gBACf;gBACA,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU,OAAO;gBAE1D,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,UAAU,CAAC;oBAC7C,OAAO;wBAAE,OAAO,YAAY,KAAK;oBAAC;gBACpC;gBACA,IAAI,CAAC,MAAM,OAAO;gBAElB,MAAM,KAAK,MAAM,gHAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBACnE,IAAI,CAAC,IAAI,OAAO;gBAEhB,OAAO;oBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;oBACpB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI,IAAI;oBACnB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI,IAAI;gBACnC,MAAM,EAAE,GAAG,AAAC,KAAa,EAAE,IAAI,MAAM,EAAE;YACzC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC7B,QAAgB,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC;YACxC,QAAgB,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YACtC,QAAgB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YACnC,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC;uCAEe,IAAA,4HAAQ,EAAC"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/admin/uploads/index.ts"],"sourcesContent":["import type { NextApiRequest, NextApiResponse } from 'next';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '../../auth/[...nextauth]';\nimport { PrismaClient } from '@prisma/client';\nimport multer from 'multer';\nimport pdfParse from 'pdf-parse';\nimport crypto from 'crypto';\n\nconst prisma = new PrismaClient();\n\n// Use in-memory storage for uploaded files\nconst upload = multer({ storage: multer.memoryStorage() });\n\n// Helper to run multer as a promise\nfunction runMiddleware(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  fn: any,\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    fn(req as any, res as any, (result: any) => {\n      if (result instanceof Error) return reject(result);\n      return resolve(result);\n    });\n  });\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n) {\n  const session = await getServerSession(req, res, authOptions as any);\n\n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  // GET: list uploads (no extractedText in list view)\n  if (req.method === 'GET') {\n    try {\n      const docs = await prisma.uploadedDocument.findMany({\n        orderBy: { createdAt: 'desc' },\n        select: {\n          id: true,\n          fileName: true,\n          mimeType: true,\n          size: true,\n          sha256: true,\n          batchCode: true,\n          labName: true,\n          createdAt: true,\n          verified: true,\n          labResult: {\n            select: { id: true },\n          },\n        },\n      });\n\n      return res.json(docs);\n    } catch (e: any) {\n      console.error('Error listing uploads', e);\n      return res\n        .status(500)\n        .json({ error: e?.message || 'Failed to list uploads' });\n    }\n  }\n\n  // POST: upload + parse PDF\n  if (req.method === 'POST') {\n    try {\n      // Parse multipart/form-data with multer\n      await runMiddleware(req, res, upload.single('file'));\n      const file = (req as any).file as Express.Multer.File | undefined;\n\n      if (!file) {\n        return res.status(400).json({ error: 'No file uploaded' });\n      }\n\n      if (file.mimetype !== 'application/pdf') {\n        return res.status(400).json({ error: 'Only PDF files are allowed' });\n      }\n\n      // Compute hash for dedupe\n      const hash = crypto\n        .createHash('sha256')\n        .update(file.buffer)\n        .digest('hex');\n\n      const existing = await prisma.uploadedDocument.findUnique({\n        where: { sha256: hash },\n        include: {\n          labResult: true,\n        },\n      });\n\n      if (existing) {\n        return res.json({\n          reused: true,\n          document: existing,\n          labResult: existing.labResult || null,\n        });\n      }\n\n      // Extract text from PDF\n      let extractedText: string | null = null;\n      try {\n        const parsed = await pdfParse(file.buffer);\n        const raw = (parsed.text || '').trim();\n        extractedText = raw.length > 0 ? raw : null;\n      } catch (e) {\n        console.error('Failed to parse PDF text', e);\n        extractedText = null;\n      }\n\n      // Tiny heuristics for batch code & lab name\n      let detectedBatchCode: string | null = null;\n      let detectedLabName: string | null = null;\n\n      if (extractedText) {\n        const lines = extractedText.split(/\\r?\\n/).map((l) => l.trim());\n\n        for (const line of lines) {\n          if (!detectedBatchCode) {\n            const m =\n              line.match(/^(batch|lot|metrc id)\\s*[:#-]?\\s*(.+)$/i) ||\n              line.match(/batch\\s*[:#-]\\s*([A-Za-z0-9\\-_.]+)/i);\n            if (m) {\n              detectedBatchCode = (m[2] || m[1] || '').trim();\n            }\n          }\n\n          if (!detectedLabName) {\n            if (\n              /labs?|laborator(y|ies)/i.test(line) &&\n              line.length <= 80 &&\n              !/limit|result|analysis/i.test(line)\n            ) {\n              detectedLabName = line;\n            }\n          }\n\n          if (detectedBatchCode && detectedLabName) break;\n        }\n      }\n\n      // Create document with extracted text\n      const document = await prisma.uploadedDocument.create({\n        data: {\n          fileName: file.originalname,\n          mimeType: file.mimetype,\n          size: file.size,\n          sha256: hash,\n          batchCode: detectedBatchCode,\n          labName: detectedLabName,\n          extractedText,\n          verified: false,\n          filePath: '',\n        },\n      });\n\n      // For now, do NOT auto-create a LabResult because LabResult\n      // requires a linked Batch in the Prisma schema.\n      // We just return null, and you can create / link a lab result\n      // later from the COA debug interface.\n      const labResult = null;\n\n      return res.json({\n        reused: false,\n        document,\n        labResult,\n      });\n    } catch (e: any) {\n      console.error('Error handling upload', e);\n      return res\n        .status(500)\n        .json({ error: e?.message || 'Failed to upload COA' });\n    }\n  }\n\n  return res.status(405).json({ error: 'Method not allowed' });\n}\n\n// Tell Next.js not to parse the body, weâ€™re using multer\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n"],"names":[],"mappings":"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"}}]
}