{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/auth/%5B...nextauth%5D.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from 'next-auth';\r\nimport CredentialsProvider from 'next-auth/providers/credentials';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcrypt';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport const authOptions: NextAuthOptions = {\r\n  session: { strategy: 'jwt' },\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: 'Credentials',\r\n      credentials: {\r\n        email: { label: 'Email', type: 'email', placeholder: 'admin@example.com' },\r\n        password: { label: 'Password', type: 'password' },\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email || !credentials?.password) return null;\r\n\r\n        const user = await prisma.adminUser.findUnique({\r\n          where: { email: credentials.email },\r\n        });\r\n        if (!user) return null;\r\n\r\n        const ok = await bcrypt.compare(credentials.password, user.password);\r\n        if (!ok) return null;\r\n\r\n        return {\r\n          id: user.id.toString(),\r\n          email: user.email,\r\n          name: user.name || undefined,\r\n          role: user.role,\r\n        } as any;\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        token.role = (user as any).role ?? 'admin';\r\n        token.id = (user as any).id ?? token.id;\r\n      }\r\n      return token;\r\n    },\r\n    async session({ session, token }) {\r\n      (session as any).user = session.user ?? {};\r\n      (session as any).user.role = token.role;\r\n      (session as any).user.id = token.id;\r\n      return session;\r\n    },\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n};\r\n\r\nexport default NextAuth(authOptions);\r\n\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACT,IAAA,oLAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;oBAAS,aAAa;gBAAoB;gBACzE,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU,OAAO;gBAE1D,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,UAAU,CAAC;oBAC7C,OAAO;wBAAE,OAAO,YAAY,KAAK;oBAAC;gBACpC;gBACA,IAAI,CAAC,MAAM,OAAO;gBAElB,MAAM,KAAK,MAAM,gHAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBACnE,IAAI,CAAC,IAAI,OAAO;gBAEhB,OAAO;oBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;oBACpB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI,IAAI;oBACnB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI,IAAI;gBACnC,MAAM,EAAE,GAAG,AAAC,KAAa,EAAE,IAAI,MAAM,EAAE;YACzC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC7B,QAAgB,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC;YACxC,QAAgB,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YACtC,QAAgB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YACnC,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC;uCAEe,IAAA,4HAAQ,EAAC"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/admin/uploads/index.ts"],"sourcesContent":["import type { NextApiRequest, NextApiResponse } from 'next';\r\nimport { getServerSession } from 'next-auth/next';\r\nimport { authOptions } from '../../auth/[...nextauth]';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport multer from 'multer';\r\nimport pdfParse from 'pdf-parse';\r\nimport crypto from 'crypto';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Use in-memory storage for uploaded files\r\nconst upload = multer({ storage: multer.memoryStorage() });\r\n\r\n// Helper to run multer as a promise\r\nfunction runMiddleware(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse,\r\n  fn: any\r\n): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    fn(req as any, res as any, (result: any) => {\r\n      if (result instanceof Error) return reject(result);\r\n      return resolve(result);\r\n    });\r\n  });\r\n}\r\n\r\nexport default async function handler(\r\n  req: NextApiRequest,\r\n  res: NextApiResponse\r\n) {\r\n  const session = await getServerSession(req, res, authOptions as any);\r\n\r\n  if (!session) {\r\n    return res.status(401).json({ error: 'Unauthorized' });\r\n  }\r\n\r\n  // GET: list uploads (no extractedText in list view)\r\n  if (req.method === 'GET') {\r\n    try {\r\n      const docs = await prisma.uploadedDocument.findMany({\r\n        orderBy: { createdAt: 'desc' },\r\n        select: {\r\n          id: true,\r\n          fileName: true,\r\n          mimeType: true,\r\n          size: true,\r\n          sha256: true,\r\n          batchCode: true,\r\n          labName: true,\r\n          createdAt: true,\r\n          verified: true,\r\n          labResult: {\r\n            select: { id: true },\r\n          },\r\n        },\r\n      });\r\n\r\n      return res.json(docs);\r\n    } catch (e: any) {\r\n      console.error('Error listing uploads', e);\r\n      return res\r\n        .status(500)\r\n        .json({ error: e?.message || 'Failed to list uploads' });\r\n    }\r\n  }\r\n\r\n  // POST: upload + parse PDF\r\n  if (req.method === 'POST') {\r\n    try {\r\n      // Parse multipart/form-data with multer\r\n      await runMiddleware(req, res, upload.single('file'));\r\n      const file = (req as any).file as Express.Multer.File | undefined;\r\n\r\n      if (!file) {\r\n        return res.status(400).json({ error: 'No file uploaded' });\r\n      }\r\n\r\n      if (file.mimetype !== 'application/pdf') {\r\n        return res.status(400).json({ error: 'Only PDF files are allowed' });\r\n      }\r\n\r\n      // Compute hash for dedupe\r\n      const hash = crypto\r\n        .createHash('sha256')\r\n        .update(file.buffer)\r\n        .digest('hex');\r\n\r\n      const existing = await prisma.uploadedDocument.findUnique({\r\n        where: { sha256: hash },\r\n        include: {\r\n          labResult: true,\r\n        },\r\n      });\r\n\r\n      if (existing) {\r\n        return res.json({\r\n          reused: true,\r\n          document: existing,\r\n          labResult: existing.labResult || null,\r\n        });\r\n      }\r\n\r\n      // Extract text from PDF\r\n      let extractedText: string | null = null;\r\n      try {\r\n        const parsed = await pdfParse(file.buffer);\r\n        const raw = (parsed.text || '').trim();\r\n        extractedText = raw.length > 0 ? raw : null;\r\n      } catch (e) {\r\n        console.error('Failed to parse PDF text', e);\r\n        extractedText = null;\r\n      }\r\n\r\n      // Tiny heuristics for batch code & lab name\r\n      let detectedBatchCode: string | null = null;\r\n      let detectedLabName: string | null = null;\r\n\r\n      if (extractedText) {\r\n        const lines = extractedText.split(/\\r?\\n/).map((l) => l.trim());\r\n\r\n        for (const line of lines) {\r\n          if (!detectedBatchCode) {\r\n            const m =\r\n              line.match(/^(batch|lot|metrc id)\\s*[:#-]?\\s*(.+)$/i) ||\r\n              line.match(/batch\\s*[:#-]\\s*([A-Za-z0-9\\-_.]+)/i);\r\n            if (m) {\r\n              detectedBatchCode = (m[2] || m[1] || '').trim();\r\n            }\r\n          }\r\n\r\n          if (!detectedLabName) {\r\n            if (\r\n              /labs?|laborator(y|ies)/i.test(line) &&\r\n              line.length <= 80 &&\r\n              !/limit|result|analysis/i.test(line)\r\n            ) {\r\n              detectedLabName = line;\r\n            }\r\n          }\r\n\r\n          if (detectedBatchCode && detectedLabName) break;\r\n        }\r\n      }\r\n\r\n      // Create document with extracted text\r\nconst document = await prisma.uploadedDocument.create({\r\n  data: {\r\n    fileName: file.originalname,\r\n    mimeType: file.mimetype,\r\n    size: file.size,\r\n    sha256: hash,\r\n    batchCode: detectedBatchCode,\r\n    labName: detectedLabName,\r\n    extractedText,\r\n    verified: false,\r\n    filePath: '',\r\n  },\r\n});\r\n\r\n// For now, do NOT auto-create a LabResult because LabResult\r\n// requires a linked Batch in the Prisma schema.\r\n// We just return null, and you can create / link a lab result\r\n// later from the COA debug interface.\r\nconst labResult = null;\r\n\r\nreturn res.json({\r\n  reused: false,\r\n  document,\r\n  labResult,\r\n});\r\n\r\n    } catch (e: any) {\r\n      console.error('Error handling upload', e);\r\n      return res\r\n        .status(500)\r\n        .json({ error: e?.message || 'Failed to upload COA' });\r\n    }\r\n  }\r\n\r\n  return res.status(405).json({ error: 'Method not allowed' });\r\n}\r\n\r\n// Tell Next.js not to parse the body, weâ€™re using multer\r\nexport const config = {\r\n  api: {\r\n    bodyParser: false,\r\n  },\r\n};\r\n"],"names":[],"mappings":"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"}}]
}