{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/auth/%5B...nextauth%5D.ts"],"sourcesContent":["import NextAuth, { NextAuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcrypt';\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: NextAuthOptions = {\n  session: { strategy: 'jwt' },\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: {\n          label: 'Email',\n          type: 'email',\n          placeholder: 'admin@example.com',\n        },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) return null;\n\n        const user = await prisma.adminUser.findUnique({\n          where: { email: credentials.email },\n        });\n        if (!user) return null;\n\n        const ok = await bcrypt.compare(credentials.password, user.password);\n        if (!ok) return null;\n\n        return {\n          id: user.id.toString(),\n          email: user.email,\n          name: user.name || undefined,\n          role: user.role,\n        } as any;\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = (user as any).role ?? 'admin';\n        token.id = (user as any).id ?? token.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      (session as any).user = session.user ?? {};\n      (session as any).user.role = token.role;\n      (session as any).user.id = token.id;\n      return session;\n    },\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n};\n\nexport default NextAuth(authOptions);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6IAAY;AAExB,MAAM,cAA+B;IAC1C,SAAS;QAAE,UAAU;IAAM;IAC3B,WAAW;QACT,IAAA,oLAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBACL,OAAO;oBACP,MAAM;oBACN,aAAa;gBACf;gBACA,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU,OAAO;gBAE1D,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,UAAU,CAAC;oBAC7C,OAAO;wBAAE,OAAO,YAAY,KAAK;oBAAC;gBACpC;gBACA,IAAI,CAAC,MAAM,OAAO;gBAElB,MAAM,KAAK,MAAM,gHAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;gBACnE,IAAI,CAAC,IAAI,OAAO;gBAEhB,OAAO;oBACL,IAAI,KAAK,EAAE,CAAC,QAAQ;oBACpB,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI,IAAI;oBACnB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI,IAAI;gBACnC,MAAM,EAAE,GAAG,AAAC,KAAa,EAAE,IAAI,MAAM,EAAE;YACzC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC7B,QAAgB,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC;YACxC,QAAgB,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YACtC,QAAgB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YACnC,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;AACrC;uCAEe,IAAA,4HAAQ,EAAC"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/lib/coaParsers/novaAnalyticLabs.ts"],"sourcesContent":["// lib/coaParsers/novaAnalyticLabs.ts\r\n\r\nexport type NovaParseResult = {\r\n  labName?: string | null;\r\n\r\n  // Identity\r\n  productName?: string | null;\r\n  batchCode?: string | null;\r\n  sampleId?: string | null;\r\n\r\n  // Jurisdiction / location\r\n  jurisdiction?: string | null;\r\n  stateCode?: string | null;\r\n\r\n  // Potency (normalized as percentages)\r\n  thcPercent?: number | null;\r\n  cbdPercent?: number | null;\r\n  totalCannabinoidsPercent?: number | null;\r\n\r\n  // QA flags\r\n  passed?: boolean | null;\r\n  pesticidesPass?: boolean | null;\r\n};\r\n\r\n/**\r\n * Nova Analytic Labs parser.\r\n *\r\n * Assumes `text` is the full extractedText from pdf-parse.\r\n * Handles both the older flower COAs (with 28.5% THC example)\r\n * and the newer TagLeaf-style edibles / tincture reports.\r\n */\r\nexport function parseNovaAnalyticLabs(rawText: string): NovaParseResult {\r\n  if (!rawText) return {};\r\n\r\n  const text = rawText.replace(/\\r/g, \"\");\r\n  const lower = text.toLowerCase();\r\n\r\n  const result: NovaParseResult = {};\r\n\r\n  // --- 1) Lab name & jurisdiction (Nova is always ME in your data) ---\r\n  result.labName = \"Nova Analytic Labs\";\r\n  result.stateCode = \"ME\";\r\n  result.jurisdiction = \"ME\";\r\n\r\n  // --- 2) Product name (line after CERTIFICATE OF ANALYSIS, skipping QA blurb) ---\r\n  result.productName = extractProductName(text);\r\n\r\n  // --- 3) Sample ID ---\r\n  const sampleMatch = text.match(/SAMPLE\\s+ID\\s*:\\s*([A-Z0-9\\-]+)/i);\r\n  if (sampleMatch) {\r\n    result.sampleId = sampleMatch[1].trim();\r\n  }\r\n\r\n  // --- 4) Batch code (BATCH NO. or BATCH #: ... ONLY – never Batch Result) ---\r\n  const batchNoMatch =\r\n    text.match(/BATCH\\s+NO\\.?\\s*[:\\-]\\s*([A-Z0-9\\-]+)/i) ||\r\n    text.match(/BATCH\\s+#\\s*[:\\-]\\s*([A-Z0-9\\-]+)/i);\r\n  if (batchNoMatch) {\r\n    result.batchCode = batchNoMatch[1].trim();\r\n  }\r\n\r\n  // --- 5) Batch result (Pass/Fail) ---\r\n  // Example: \"Client: Bioactive LLC // Batch Result: Pass\"\r\n  const batchResultMatch = text.match(\r\n    /BATCH\\s+RESULT\\s*[:\\-]\\s*(PASS(?:ED)?|FAIL(?:ED)?)/i\r\n  );\r\n  if (batchResultMatch) {\r\n    const v = batchResultMatch[1].toLowerCase();\r\n    result.passed = v.startsWith(\"pass\");\r\n  }\r\n\r\n  // Also consider explicit pesticides line:\r\n  // e.g. \"PESTICIDES\" + \"PASS\" / \"FAIL\"\r\n  const pesticidesMatch = text.match(/PESTICIDES\\s+(\\bPASS\\b|\\bFAIL\\b)/i);\r\n  if (pesticidesMatch) {\r\n    result.pesticidesPass = pesticidesMatch[1].toLowerCase() === \"pass\";\r\n  }\r\n\r\n  // --- 6) Potency parsing ---\r\n  // We try Nova's big analyte table first, then fall back\r\n  // to more generic % searches.\r\n\r\n  // THC – we prefer TOTAL THC if present; otherwise Δ-THC.\r\n  const totalThc =\r\n    extractPercentByLabel(text, \"TOTAL THC\") ??\r\n    extractPercentByLabel(text, \"Total THC\");\r\n  const deltaThc =\r\n    extractPercentByLabel(text, \"Δ-THC\") ??\r\n    extractPercentByLabel(text, \"Delta-9-THC\");\r\n\r\n  if (totalThc != null) {\r\n    result.thcPercent = totalThc;\r\n  } else if (deltaThc != null) {\r\n    result.thcPercent = deltaThc;\r\n  }\r\n\r\n  // CBD – prefer TOTAL CBD; fall back to CBD.\r\n  const totalCbd =\r\n    extractPercentByLabel(text, \"TOTAL CBD\") ??\r\n    extractPercentByLabel(text, \"Total CBD\");\r\n  const cbd = extractPercentByLabel(text, \"CBD\");\r\n\r\n  if (totalCbd != null) {\r\n    result.cbdPercent = totalCbd;\r\n  } else if (cbd != null) {\r\n    result.cbdPercent = cbd;\r\n  }\r\n\r\n  // Total cannabinoids – look for \"TOTAL CANNABINOIDS\"\r\n  let totalCann =\r\n    extractPercentByLabel(text, \"TOTAL CANNABINOIDS\") ??\r\n    extractPercentByLabel(text, \"Total Cannabinoids\");\r\n\r\n  // Some newer Nova COAs put \"Total Cannabinoids\" on its own line\r\n  // with the % above it (your 3.02 % example). We handle that here.\r\n  if (totalCann == null) {\r\n    totalCann = extractPercentNearLabelBackward(text, \"Total Cannabinoids\", 160);\r\n  }\r\n\r\n  if (totalCann != null) {\r\n    result.totalCannabinoidsPercent = totalCann;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// ---------------------------------------------------------\r\n// Helpers\r\n// ---------------------------------------------------------\r\n\r\n/**\r\n * Grab the product name from near the top of the report.\r\n *\r\n * Pattern in your examples:\r\n *   CERTIFICATE OF ANALYSIS\r\n *   * For quality...\r\n *   Nano BS CBD #1 (Edible Liquid)\r\n *\r\n *   CERTIFICATE OF ANALYSIS\r\n *   * FOR QUALITY...\r\n *   600MG RELEAF TINCTURE - PINACOLADA (TINCTURE)\r\n *   PRODUCED: ...\r\n */\r\nfunction extractProductName(text: string): string | null {\r\n  const upper = text.toUpperCase();\r\n  const idx = upper.indexOf(\"CERTIFICATE OF ANALYSIS\");\r\n\r\n  const window = idx >= 0 ? text.slice(idx, idx + 800) : text.slice(0, 800);\r\n\r\n  const lines = window\r\n    .split(/\\r?\\n/)\r\n    .map((l) => l.trim())\r\n    .filter(Boolean);\r\n\r\n  const filtered = lines.filter((l) => {\r\n    const lu = l.toUpperCase();\r\n    if (lu.includes(\"CERTIFICATE OF ANALYSIS\")) return false;\r\n    if (lu.includes(\"FOR QUALITY ASSURANCE\")) return false;\r\n    if (lu.startsWith(\"* FOR QUALITY ASSURANCE\")) return false;\r\n    return true;\r\n  });\r\n\r\n  return filtered[0] || null;\r\n}\r\n\r\n/**\r\n * Extract a percentage like \"CBD0.902 %\" or \"CBD 0.902 %\"\r\n * or \"0.902 % CBD\" from anywhere in the text.\r\n */\r\nfunction extractPercentByLabel(\r\n  text: string,\r\n  label: string\r\n): number | null {\r\n  // Pattern 1: LABEL...12.3 %\r\n  const pattern1 = new RegExp(\r\n    `${escapeRegExp(label)}[^0-9]{0,10}([0-9]+(?:\\\\.[0-9]+)?)\\\\s*%`,\r\n    \"i\"\r\n  );\r\n  const m1 = text.match(pattern1);\r\n  if (m1) {\r\n    const v = parseFloat(m1[1]);\r\n    if (!Number.isNaN(v)) return v;\r\n  }\r\n\r\n  // Pattern 2: 12.3 % LABEL\r\n  const pattern2 = new RegExp(\r\n    `([0-9]+(?:\\\\.[0-9]+)?)\\\\s*%\\\\s*${escapeRegExp(label)}`,\r\n    \"i\"\r\n  );\r\n  const m2 = text.match(pattern2);\r\n  if (m2) {\r\n    const v = parseFloat(m2[1]);\r\n    if (!Number.isNaN(v)) return v;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * For the weird \"3.02 % ... Total Cannabinoids\" layout:\r\n *\r\n * 2.93 %\r\n * 0.0851 %\r\n * 3.02 %\r\n * CBD\r\n * CBG\r\n * Total Cannabinoids\r\n *\r\n * We locate \"Total Cannabinoids\" and scan backwards\r\n * within a small window for the last % number.\r\n */\r\nfunction extractPercentNearLabelBackward(\r\n  text: string,\r\n  label: string,\r\n  windowSize: number\r\n): number | null {\r\n  const idx = text.toLowerCase().indexOf(label.toLowerCase());\r\n  if (idx < 0) return null;\r\n\r\n  const start = Math.max(0, idx - windowSize);\r\n  const window = text.slice(start, idx);\r\n\r\n  const matches = Array.from(\r\n    window.matchAll(/([0-9]+(?:\\.[0-9]+)?)\\s*%/g)\r\n  );\r\n  if (!matches.length) return null;\r\n\r\n  const last = matches[matches.length - 1];\r\n  const v = parseFloat(last[1]);\r\n  return Number.isNaN(v) ? null : v;\r\n}\r\n\r\n/** Escape a string so it can safely be used inside a RegExp */\r\nfunction escapeRegExp(str: string): string {\r\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 299, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/lib/coaParsers/registry.ts"],"sourcesContent":["// lib/coaParsers/registry.ts\r\n\r\nimport { parseNovaAnalyticLabs, NovaParseResult } from \"./novaAnalyticLabs\";\r\n\r\nexport type CoaParseInput = {\r\n  fileName?: string;\r\n  extractedText: string;\r\n  labNameCandidate?: string | null;\r\n};\r\n\r\nexport type CoaParseResult = {\r\n  labName?: string | null;\r\n\r\n  productName?: string | null;\r\n  batchCode?: string | null;\r\n  sampleId?: string | null;\r\n\r\n  jurisdiction?: string | null;\r\n  stateCode?: string | null;\r\n\r\n  thcPercent?: number | null;\r\n  cbdPercent?: number | null;\r\n  totalCannabinoidsPercent?: number | null;\r\n\r\n  passed?: boolean | null;\r\n  pesticidesPass?: boolean | null;\r\n};\r\n\r\n/**\r\n * Central COA parsing entrypoint used by /api/admin/uploads.\r\n *\r\n * You can extend this later with additional lab-specific parsers\r\n * and state-specific templates.\r\n */\r\nexport function parseCoa(input: CoaParseInput): CoaParseResult {\r\n  const text = (input.extractedText || \"\").replace(/\\r/g, \"\");\r\n  const lower = text.toLowerCase();\r\n\r\n  let result: CoaParseResult = {};\r\n\r\n  // --- Lab-specific detection ---\r\n\r\n  const isNova = lower.includes(\"nova analytic labs\");\r\n  if (isNova) {\r\n    const nova: NovaParseResult = parseNovaAnalyticLabs(text);\r\n\r\n    result = {\r\n      ...result,\r\n      ...nova,\r\n      // Ensure lab name & jurisdiction always set\r\n      labName: nova.labName ?? \"Nova Analytic Labs\",\r\n      jurisdiction: nova.jurisdiction ?? \"ME\",\r\n      stateCode: nova.stateCode ?? \"ME\",\r\n    };\r\n  }\r\n\r\n  // --- Generic lab name fallback ---\r\n  if (!result.labName && input.labNameCandidate) {\r\n    result.labName = input.labNameCandidate;\r\n  }\r\n\r\n  // --- Generic pass/fail fallback (in case a lab parser didn’t set it) ---\r\n  if (result.passed == null) {\r\n    const m = text.match(/BATCH\\s+RESULT\\s*[:\\-]\\s*(PASS(?:ED)?|FAIL(?:ED)?)/i);\r\n    if (m) {\r\n      const v = m[1].toLowerCase();\r\n      result.passed = v.startsWith(\"pass\");\r\n    }\r\n  }\r\n\r\n  // --- Generic batch code fallback ---\r\n  if (!result.batchCode) {\r\n    // 1) BATCH NO.: ABC123-XYZ\r\n    const m1 = text.match(/BATCH\\s+NO\\.?\\s*[:\\-]\\s*([A-Z0-9\\-]+)/i);\r\n    if (m1) {\r\n      result.batchCode = m1[1].trim();\r\n    } else {\r\n      // 2) BATCH: ..., but explicitly ignore \"Batch Result\" and \"Batch Size\"\r\n      const m2 = text.match(\r\n        /BATCH(?!\\s+(RESULT|SIZE))\\s*[:\\-]\\s*([A-Z0-9\\-]+)/i\r\n      );\r\n      if (m2) {\r\n        result.batchCode = m2[2].trim();\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;;AAE7B;;AAgCO,SAAS,SAAS,KAAoB;IAC3C,MAAM,OAAO,CAAC,MAAM,aAAa,IAAI,EAAE,EAAE,OAAO,CAAC,OAAO;IACxD,MAAM,QAAQ,KAAK,WAAW;IAE9B,IAAI,SAAyB,CAAC;IAE9B,iCAAiC;IAEjC,MAAM,SAAS,MAAM,QAAQ,CAAC;IAC9B,IAAI,QAAQ;QACV,MAAM,OAAwB,IAAA,uJAAqB,EAAC;QAEpD,SAAS;YACP,GAAG,MAAM;YACT,GAAG,IAAI;YACP,4CAA4C;YAC5C,SAAS,KAAK,OAAO,IAAI;YACzB,cAAc,KAAK,YAAY,IAAI;YACnC,WAAW,KAAK,SAAS,IAAI;QAC/B;IACF;IAEA,oCAAoC;IACpC,IAAI,CAAC,OAAO,OAAO,IAAI,MAAM,gBAAgB,EAAE;QAC7C,OAAO,OAAO,GAAG,MAAM,gBAAgB;IACzC;IAEA,0EAA0E;IAC1E,IAAI,OAAO,MAAM,IAAI,MAAM;QACzB,MAAM,IAAI,KAAK,KAAK,CAAC;QACrB,IAAI,GAAG;YACL,MAAM,IAAI,CAAC,CAAC,EAAE,CAAC,WAAW;YAC1B,OAAO,MAAM,GAAG,EAAE,UAAU,CAAC;QAC/B;IACF;IAEA,sCAAsC;IACtC,IAAI,CAAC,OAAO,SAAS,EAAE;QACrB,2BAA2B;QAC3B,MAAM,KAAK,KAAK,KAAK,CAAC;QACtB,IAAI,IAAI;YACN,OAAO,SAAS,GAAG,EAAE,CAAC,EAAE,CAAC,IAAI;QAC/B,OAAO;YACL,uEAAuE;YACvE,MAAM,KAAK,KAAK,KAAK,CACnB;YAEF,IAAI,IAAI;gBACN,OAAO,SAAS,GAAG,EAAE,CAAC,EAAE,CAAC,IAAI;YAC/B;QACF;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jesse/Documents/cartfax_complete_v2/pages/api/admin/uploads/index.ts"],"sourcesContent":["// pages/api/admin/uploads/index.ts\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { getServerSession } from 'next-auth/next';\nimport { authOptions } from '../../auth/[...nextauth]';\nimport { PrismaClient } from '@prisma/client';\nimport multer from 'multer';\nimport pdfParse from 'pdf-parse';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport crypto from 'crypto';\n\nimport { parseCoa } from '../../../../lib/coaParsers/registry';\n\nconst prisma = new PrismaClient();\n\n// Multer in-memory storage (we write the file ourselves)\nconst upload = multer({ storage: multer.memoryStorage() });\n\n// Helper to run multer (or any middleware) in Next API route\nfunction runMiddleware(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  fn: Function\n) {\n  return new Promise<void>((resolve, reject) => {\n    fn(req, res, (result: unknown) => {\n      if (result instanceof Error) return reject(result);\n      return resolve();\n    });\n  });\n}\n\n// Disable Next’s default body parser for this route\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  const session = await getServerSession(req, res, authOptions);\n\n  if (!session || (session.user as any)?.role !== 'admin') {\n    res.status(401).json({ error: 'Unauthorized' });\n    return;\n  }\n\n  if (req.method === 'GET') {\n    try {\n      const docs = await prisma.uploadedDocument.findMany({\n        orderBy: { createdAt: 'desc' },\n        include: {\n          labResult: {\n            select: { id: true },\n          },\n        },\n      });\n\n      res.status(200).json(docs);\n      return;\n    } catch (e: any) {\n      console.error('Failed to list uploads', e);\n      res\n        .status(500)\n        .json({ error: e?.message || 'Failed to list uploads' });\n      return;\n    }\n  }\n\n  if (req.method === 'POST') {\n    try {\n      await runMiddleware(req, res, upload.single('file'));\n\n      const file = (req as any).file as\n        | {\n            originalname: string;\n            mimetype: string;\n            size: number;\n            buffer: Buffer;\n          }\n        | undefined;\n\n      if (!file) {\n        res.status(400).json({ error: 'No file uploaded' });\n        return;\n      }\n\n      if (file.mimetype !== 'application/pdf') {\n        res.status(400).json({ error: 'Only PDF uploads are supported' });\n        return;\n      }\n\n      // Hash buffer to detect duplicates\n      const sha256 = crypto\n        .createHash('sha256')\n        .update(file.buffer)\n        .digest('hex');\n\n      const existing = await prisma.uploadedDocument.findUnique({\n        where: { sha256 },\n        include: {\n          labResult: true,\n        },\n      });\n\n      if (existing) {\n        res.status(200).json({\n          reused: true,\n          document: existing,\n          labResult: existing.labResult || null,\n        });\n        return;\n      }\n\n      // Ensure uploads directory\n      const relativePath = path.join('uploads', 'coas', `${sha256}.pdf`);\n      const fullPath = path.join(process.cwd(), relativePath);\n      await fs.mkdir(path.dirname(fullPath), { recursive: true });\n\n      // Write file\n      await fs.writeFile(fullPath, file.buffer);\n\n      // Extract raw text from PDF\n      let extractedText = '';\n      try {\n        const parsedPdf = await pdfParse(file.buffer);\n        extractedText = parsedPdf.text || '';\n      } catch (err) {\n        console.error('pdf-parse failed, continuing with empty text', err);\n      }\n\n      // Base parsed info from lab-specific registry (if present)\n      let parsed: any = null;\n      try {\n        if (typeof parseCoa === 'function') {\n          parsed = parseCoa(extractedText);\n        }\n      } catch (err) {\n        console.error('parseCoa threw', err);\n      }\n\n      // --- Heuristic extraction / normalization ---\n\n      const looksLikeNova = /Nova Analytic Labs/i.test(extractedText);\n\n      // Lab name\n      let labName: string | null =\n        parsed?.labName || detectLabNameFromText(extractedText);\n\n      if (looksLikeNova && !labName) {\n        labName = 'Nova Analytic Labs';\n      }\n\n      // Batch code & pass/fail\n      let batchCode: string | null =\n        (parsed?.batchCode as string | undefined)?.trim() || null;\n      let passed: boolean | null =\n        typeof parsed?.passed === 'boolean' ? parsed.passed : null;\n\n      if (looksLikeNova) {\n        const novaMeta = refineNovaMetadata(\n          extractedText,\n          batchCode,\n          passed\n        );\n        batchCode = novaMeta.batchCode ?? batchCode;\n        passed = novaMeta.passed ?? passed;\n      }\n\n      if (!batchCode) {\n        batchCode = detectBatchCodeFromText(extractedText);\n      }\n\n      // Jurisdiction & state (for now, Nova → ME)\n      let stateCode: string | null = parsed?.stateCode || null;\n      let jurisdiction: string | null = parsed?.jurisdiction || null;\n\n      if (!stateCode && looksLikeNova) {\n        stateCode = 'ME';\n      }\n      if (!jurisdiction && stateCode) {\n        jurisdiction = stateCode;\n      }\n\n      // Sample type / matrix / sample ID\n      const sampleType =\n        parsed?.sampleType || detectMatrix(extractedText) || null;\n      const sampleId =\n        parsed?.sampleId || detectSampleId(extractedText) || null;\n\n      // Potency\n      let thcPercent: number | null =\n        parsed?.thcPercent ?? detectThcPercent(extractedText);\n      let cbdPercent: number | null =\n        parsed?.cbdPercent ?? detectCbdPercent(extractedText);\n      let totalCannabinoidsPercent: number | null =\n        parsed?.totalCannabinoidsPercent ??\n        detectTotalCannabinoidsPercent(extractedText);\n\n      if (looksLikeNova) {\n        if (totalCannabinoidsPercent == null) {\n          totalCannabinoidsPercent =\n            detectNovaTotalCannabinoidsPercent(extractedText);\n        }\n        if (cbdPercent == null) {\n          cbdPercent = detectNovaCbdPercent(extractedText);\n        }\n      }\n\n      // --- Persist UploadedDocument first ---\n\n      const document = await prisma.uploadedDocument.create({\n        data: {\n          filePath: relativePath.replace(/\\\\/g, '/'),\n          fileName: file.originalname,\n          mimeType: file.mimetype,\n          size: file.size,\n          sha256,\n          extractedText,\n          labName: labName || null,\n          batchCode: batchCode || null,\n          uploader: (session.user as any)?.email || null,\n          verified: false,\n        },\n      });\n\n      // --- Upsert Lab (if we found a name) ---\n\n      let labRecord = null;\n      if (labName) {\n        const slug = slugify(labName);\n        const existingLab = await prisma.lab.findUnique({\n          where: { slug },\n        });\n\n        if (existingLab) {\n          labRecord = await prisma.lab.update({\n            where: { id: existingLab.id },\n            data: {\n              name: labName,\n              stateCode: stateCode || existingLab.stateCode,\n            },\n          });\n        } else {\n          labRecord = await prisma.lab.create({\n            data: {\n              name: labName,\n              slug,\n              stateCode,\n            },\n          });\n        }\n      }\n\n      // --- Upsert Batch (using batchCode + jurisdiction heuristically) ---\n\n      let batchRecord = null;\n      if (batchCode) {\n        const existingBatch = await prisma.batch.findFirst({\n          where: {\n            batchCode,\n            jurisdiction: jurisdiction || undefined,\n          },\n        });\n\n        const batchData = {\n          batchCode,\n          productName: parsed?.productName || null,\n          jurisdiction,\n          stateCode,\n          isActive: true,\n        };\n\n        if (existingBatch) {\n          batchRecord = await prisma.batch.update({\n            where: { id: existingBatch.id },\n            data: batchData,\n          });\n        } else {\n          batchRecord = await prisma.batch.create({\n            data: batchData,\n          });\n        }\n      }\n\n      // --- Create LabResult if we have at least a batch or lab ---\n\n      let labResult = null;\n      if (batchRecord || labRecord) {\n        labResult = await prisma.labResult.create({\n          data: {\n            // link to batch & lab if present\n            ...(batchRecord\n              ? { batch: { connect: { id: batchRecord.id } } }\n              : {}),\n            ...(labRecord\n              ? { lab: { connect: { id: labRecord.id } } }\n              : {}),\n\n            uploadedDocument: { connect: { id: document.id } },\n\n            sampleId,\n            sampleType,\n\n            thcPercent,\n            cbdPercent,\n            totalCannabinoidsPercent,\n\n            passed,\n\n            analyteSummary: parsed?.analyteSummary || null,\n            rawJson: parsed?.rawJson || null,\n          },\n        });\n      }\n\n      res.status(200).json({\n        reused: false,\n        document,\n        labResult,\n      });\n      return;\n    } catch (e: any) {\n      console.error('Error handling upload', e);\n      res\n        .status(500)\n        .json({ error: e?.message || 'Error handling upload' });\n      return;\n    }\n  }\n\n  res.status(405).end();\n}\n\n// ---------- Helpers ----------\n\nfunction slugify(name: string): string {\n  return name\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/(^-|-$)+/g, '');\n}\n\nfunction detectLabNameFromText(text: string): string | null {\n  if (/Nova Analytic Labs/i.test(text)) return 'Nova Analytic Labs';\n  return null;\n}\n\nfunction detectBatchCodeFromText(text: string): string | null {\n  // Modern Nova: \"BATCH NO.: 600RCRTPC113\"\n  const m1 = text.match(\n    /BATCH\\s*(?:NO\\.?|NUMBER)\\s*[:\\-]\\s*([A-Z0-9\\-]+)/i\n  );\n  if (m1) return m1[1].trim();\n\n  // Older Nova example: \"CLIENT: ... // BATCH: FAIL\"\n  const m2 = text.match(/BATCH:\\s*([A-Z0-9\\-]+)/i);\n  if (m2) {\n    const candidate = m2[1].trim();\n    const upper = candidate.toUpperCase();\n    if (!['PASS', 'PASSED', 'FAIL', 'FAILED'].includes(upper)) {\n      return candidate;\n    }\n  }\n\n  return null;\n}\n\nfunction refineNovaMetadata(\n  text: string,\n  currentBatchCode?: string | null,\n  currentPassed?: boolean | null\n): { batchCode: string | null; passed: boolean | null } {\n  let batchCode = currentBatchCode ?? null;\n  let passed = currentPassed ?? null;\n\n  // \"BATCH RESULT: Pass\" / \"BATCH RESULT: Failed\"\n  const resultMatch = text.match(\n    /BATCH RESULT:\\s*(PASS(?:ED)?|FAIL(?:ED)?)/i\n  );\n  if (resultMatch) {\n    const word = resultMatch[1].toUpperCase();\n    passed = word.startsWith('PASS');\n\n    if (\n      batchCode &&\n      ['PASS', 'PASSED', 'FAIL', 'FAILED'].includes(\n        batchCode.toUpperCase()\n      )\n    ) {\n      // That wasn't a real batch code, just the result\n      batchCode = null;\n    }\n  }\n\n  // If we cleared batchCode or never had one, look for \"BATCH NO.: ...\"\n  if (!batchCode) {\n    const m = text.match(\n      /BATCH\\s*(?:NO\\.?|NUMBER)\\s*[:\\-]\\s*([A-Z0-9\\-]+)/i\n    );\n    if (m) {\n      batchCode = m[1].trim();\n    }\n  }\n\n  return { batchCode, passed };\n}\n\nfunction detectMatrix(text: string): string | null {\n  const m = text.match(/MATRIX:\\s*([A-Za-z ]+)/i);\n  return m ? m[1].trim() : null;\n}\n\nfunction detectSampleId(text: string): string | null {\n  const m = text.match(/SAMPLE ID:\\s*([A-Z0-9\\-]+)/i);\n  return m ? m[1].trim() : null;\n}\n\n// Very rough THC detector\nfunction detectThcPercent(text: string): number | null {\n  // Δ-THC:28.5 %\n  const m1 = text.match(/Δ-?THC[:\\s]*([0-9]+(?:\\.[0-9]+)?)\\s*%/i);\n  if (m1) return parseFloat(m1[1]);\n\n  // Total THC ...\n  const m2 = text.match(\n    /TOTAL THC[^\\n]*?\\s([0-9]+(?:\\.[0-9]+)?)\\s*%/i\n  );\n  if (m2) return parseFloat(m2[1]);\n\n  return null;\n}\n\n// Generic CBD % detector\nfunction detectCbdPercent(text: string): number | null {\n  // CBD0.902 %\n  const m = text.match(/CBD\\s*([0-9]+(?:\\.[0-9]+)?)\\s*%/);\n  if (m) return parseFloat(m[1]);\n  return null;\n}\n\n// Generic \"Total Cannabinoids\" detector\nfunction detectTotalCannabinoidsPercent(text: string): number | null {\n  const m = text.match(\n    /TOTAL CANNABINOIDS[:\\s]*([0-9]+(?:\\.[0-9]+)?)\\s*%/i\n  );\n  if (m) return parseFloat(m[1]);\n  return null;\n}\n\n// Nova-specific \"Total Cannabinoids\" (covers both examples you pasted)\nfunction detectNovaTotalCannabinoidsPercent(\n  text: string\n): number | null {\n  // \"Total Cannabinoids\\n3.02 %\"\n  const m1 = text.match(\n    /Total Cannabinoids[\\s:]*([0-9]+(?:\\.[0-9]+)?)\\s*%/i\n  );\n  if (m1) return parseFloat(m1[1]);\n\n  // \"TOTAL CANNABINOIDS:29.1 %\"\n  const m2 = text.match(\n    /TOTAL CANNABINOIDS[:\\s]*([0-9]+(?:\\.[0-9]+)?)\\s*%/i\n  );\n  if (m2) return parseFloat(m2[1]);\n\n  return null;\n}\n\n// Nova-specific CBD % (handles \"CBD2.93 %\" and \"CBD0.902 %\")\nfunction detectNovaCbdPercent(text: string): number | null {\n  const m = text.match(/CBD\\s*([0-9]+(?:\\.[0-9]+)?)\\s*%/);\n  if (m) return parseFloat(m[1]);\n  return null;\n}\n"],"names":[],"mappings":"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"}}]
}